В архитектуре Vertical Slice рекомендуется придерживаться следующих правил именования.

### AgregateFolder

Для примера возьмём агрегат Person. Все примеры классов будут на примере реализации агрегата Person.

Имя формируется из названия агрегата во множественном числе. Для агрегата Person папка будет иметь название **Persons**.

#### FeatureFolder

Описание и содержимое FeatureFolder можно почитать тут.

Имя должно описывать какое-то действие с агрегатом и иметь название такое же, как и у c# методов. То есть должны

составляться, как минимум из глагола и существительного (соглашение verb-noun). Например, **UpdatePerson**.

#### Команда

Имя команды формируется на основании следующего принципа: \{Название FeatureFolder\}Command. Например,

**UpdatePersonCommand**.

#### Запрос

Имя запроса формируется на основании следующего принципа: \{Название FeatureFolder\}Query. Например,

**GetPersonDetailQuery**.

#### Обработчик команды

Имя обработчика команды формируется на основании следующего принципа: \{Название FeatureFolder\}CommandHandler.

Например, **UpdatePersonCommandHandler**.

#### Обработчик запроса

Имя обработчика запроса формируется на основании следующего принципа: \{Название FeatureFolder\}QueryHandler. Например,

**GetPersonDetailQueryHandler**.

#### Название маппера

Имя маппера формируется на основании следующего принципа: \{Название FeatureFolder\}Mapper. Например,

**UpdatePersonMapper**.

Если маппер расположен внутри папки сервиса, то имя маппера формируется на основании следующего принципа: \{Название

ServiceFolder\}Mapper. Например, SberbankApiMapper.

#### Название класса с настройками

Имя класса с настройками формируется на основании следующего принципа: \{Название FeatureFolder\}Options. Например,

**UpdatePersonOptions**.

Если класс настроек расположен внутри папки сервиса, то имя класса с настройками формируется на основании следующего

принципа: \{Название ServiceFolder\}Options. Например, SberbankApiOptions.

Если класс настроек расположен внутри папки \[AgregateFolder\]/Shared, то имя класса с настройками формируется на основании

следующего принципа: \{Название AgregateFolder\}Options. Например, PersonsOptions.

Если класс настроек расположен внутри корневой папки Shared, то имя класса с настройками формируется на основании

следующего принципа: \{Любое название\}Options. Например, SomeOptions.

#### Название пайплайна

Имя пайплайна формируется на основании следующего принципа: \{Любое название\}Behavior. Например, **ExceptionBehavior**.

#### Перечисления для метрик

Перечисления для метрик формируются на основании следующего принципа: \{Название FeatureFolder\}MetricType. Например,

**UpdatePersonMetricType.**

#### Конфигурация сервисов

Имя класса с конфигурацией сервисов формируется на основании следующего принципа: \{Название

FeatureFolder\}ServicesConfiguration. Например, **UpdatePersonServicesConfiguration**.

Если класс с конфигурацией расположен внутри папки \[AgregateFolder\]/Shared, то имя класса с конфигурацией формируется на

основании следующего принципа: \{Название AgregateFolder\}ServicesConfiguration. Например, PersonsServicesConfiguration.

Если класс с конфигурацией расположен внутри корневой папки Shared, то имя класса с конфигурацией должно быть:

ServicesConfiguration.

#### Валидатор запроса

Имя класса валидатора запроса формируется на основании следующего принципа: \{Название класса запроса\}Validator.

Например, **GetPersonDetailQueryValidator**.

#### Валидатор команды

Имя класса валидатора команды формируется на основании следующего принципа: \{Название класса команды\}Validator.

Например, **UpdatePersonCommandValidator**.

#### Валидатор Dto

Имя класса валидатора Dto формируется на основании следующего принципа: \{Имя класса Dto\}Validator. Например,

**PersonDtoValidator**.

Dto должен быть определен, как **immutable record**.

#### Входные и выходные данные запроса

К названиям классов, описывающие входные и выходные данные команды(запроса) необходимо добавлять Dto. Это не

относится к названию самой команды(запроса). Например, **PersonDto.**

#### Названия классов описывающие таблицы в базе данных

К названиям классов, описывающие таблицы в базе данных можно (желательно) не добавлять суффикс Db или Entity.

Местонахождение таких классов описано в данном документе.

#### Названия классов описывающие частичные представления таблиц или объединения таблиц базы данных

К названиям классов описывающие частичные представления таблиц или объединения таблиц базы данных, например View в

базе данных можно (желательно) не добавлять суффикс View. Местонахождение таких классов описано в данном документе.

#### Названия классов работающие с базой данных

К названиями классов, содержащие методы для работы с базой данных добавляются суффиксы:

**Provider** или **Fetcher** - если класс имеет только методы, отдающие данные из базы данных;

**Repository** - если класс имеет методы и отдающие данные из бд и изменяющие данные в бд;

Если класс заполняет внутренние зависимости сущности, то добавлять суффикс **Populater**, **Filler** или **DependeciesLoader.**

#### Названия классов описывающие бизнес-правила

Название бизнес правила должно описывать то, что нельзя нарушать и иметь суффикс BusinessRule. Например:

ReturnClaimHasManualProcessingStatusBusinessRule - Заявление возврата имеет статус ManualProcessingStatus

ClaimAndResponseMustBeEquivalentBusinessRule - Заявление и ответ (от исходящего запроса) должны быть одинаковые

OrdersMustNotHaveDuplicatesBusinessRule - Заказы не должны дублироваться

### Советы по именованию классов

1\. Не нужно использовать слово Service или Manager в названиях классов. Такие классы могут содержать любую логику, что

нарушает SOLID и другие принципы. Нужно называть класс так, как для чего он предназначен.

Пример как нужно называть класс: ReturnClaimUpdater, ReturnClaimRegister и т.д.
